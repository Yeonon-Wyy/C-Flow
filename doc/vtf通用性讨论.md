## VTF通用性的价值与代价

### 1. 什么是程序的“通用性”

程序的通用性通常是指“这个程序被用到几乎任何场景，都不需要或者仅需要少量修改即可使用”。听起来很厉害，但实际上很难做到。目前也没有听说哪一个软件或者框架能够做到这一点。著名的Spring（Java Web领域的框架）框架也只是在Java Web这个领域实现了某种程度上的“通用”，几乎所有Java Web开发者都可以仅需少量修改就搭建起一个Java Web服务。

所以我认为我们在开发通用性程序或者重构代码使其通用的时候，目标没必要设置得那么大，可以限定到某个具体的应用领域，只要在某个应用领域实现通用即可，否则可能会陷入到被称为“过渡工程”的现象中。关于过度工程，有一个"故事"：

> 传说 1960 年代美俄“太空竞赛”的时候，NASA 遇到一个严重的技术问题：宇航员需要一支可以在外太空的真空中写字的钢笔。最后 NASA 耗资150万美元研制出了这样的钢笔。可惜这种钢笔在市场上并不行销。**俄国人也遇到同样的问题。他们使用了铅笔。**

虽然故事是虚构的，但也引出了一个思考，在软件编程中，为了所谓的“通用性”而设计出复杂的架构是否是值得的？这个问题也是本文想要讨论的。

### 2. 通用性的价值

通用性自然是有价值的，它确实可以使得程序可以很大程度上的“复用”，提升开发效率。例如C++ STL库，Netty网络库，libevent等等，使用他们，开发者不需要编写样板式代码，仅需要关注具体的业务逻辑即可。甚至在Java Web领域，使用Spring框架，仅需要一行代码，即可启动一个可持续监听请求的服务。假设没有这种通用性很强的框架，为了启动一个服务，我们往往需要编写大量的代码来完成，而且这些大量的代码也许大部分是和其他程序是一样的。

上述是我认为的通用性的价值，看起来十分美好，但也不是没有弊端。

### 3. 通用性的代价

> 任何事物都不可能是完全完美，甚至看起来完美的事物，在它背后也许隐藏来更大的危险。

程序的通用性确确实实的降低了开发者的开发效率，但往往这类程序的架构会非常复杂，其架构设计以及源码实现通常让人百思不得其解，读者很难理解。这里再拿Spring框架作为例子，其源码异常复杂，随处可见的“反射”以及花里胡哨的设计模式，经常为了完成一个从业务侧看起来很简单的事，而绕来绕去，跨了好几层才能完成。

除了代码架构以及实现复杂以外，效率以及性能也会受到一定程度的影响，因为多绕几道弯相比于一把梭来说，单从CPU执行的指令数量来看都会多不少，更不用说可能存在的内存占用等情况了。当然，当框架应用到某个具体的场景的时候，这点性能损耗往往不是大头。

上述就是我想说的为了程序通用性而付出的代价，这个代价包括程序架构变得复杂，性能有少量的损耗等等。不过好在这些代价通常是框架开发者需要付出的，普的使用者可以不用太过于关注（这里存在一个“代价的转移”）。**所以，如果你是框架的使用者，恭喜你，本节所讨论的这些代价你都可以不关心，而如果你是框架开发者，并且着力于其“通用性”，那么请小心考量需要付出的代价是否能抵过产生的价值。**

### 4. VTF的通用性

VTF的目标是为任何符合“任务流”模型的业务提供方便统一的接口，所以自然而然地，通用性也是VTF所必须要要考虑的事。为了满足各种各样的业务，我在框架中大量使用了C++的模板。模板确实可以提升通用性，使得框架内部不需要考虑实际的业务处理对象的具体实现，只需要知道接口即可。但这也使得编程变得想对困难需要，需要解决很多由于使用模板带来的问题，例如“模板不支持分离编译”的问题。这使得的我转而考虑将VTF设计成header-only的形式，但header-only也存在编译时间长以及修改某一处通常会引发全量编译的问题。

再举一个更贴近具体实现的例子。vtf::pipeline::PipeNode的创建需要用户给出一个回调函数，且必须具备这样的函数签名：

```c++
std::function<bool(std::shared_ptr<Item>)>;
```

我从一开始设计的时候，这个处理函数应该是一个可变参数。可到后来，我发现我的框架内部无法处理可变参数的情况。因为这里的Item虽然是模板类型，但他其实是受到vtf::pipeline::Pipeline对象创建的时候指定的模板类型限制的，即vtf::pipeline::Pipeline对象创建的时候模板类型是什么，这里的Item就是什么。我的框架内部也就只能处理vtf::pipeline::Pipeline指定的类型。如果这个回调函数允许可变参数，框架内部将无法得知具体类型，也就会出现各种各样的编译错误。如果要解决编译错误，则只能固定类型，但如果固定了类型，那么将无法处理其他类型，通用性必然大打折扣。所以，最终我选择限制了这个函数签名。

在这个例子中还有一个问题就是，pipeNode的业务逻辑只提供了函数式接口，这也比较大的限制了用户的行为。用户只能通过绑定function对象来完成一些更加复杂的操作。例如：

```c++
	auto FDNode = ppl->addPipeNode(
		{
			.id = 1,
			.name = "FDNode",
			.pipelineScenarios = {CVTestScenario::PREVIEW},
			.processCallback = std::bind(&dnnfacedetect::detect, dnnfacedetect::getInstance(), std::placeholders::_1),
			.configProgress = std::bind(&dnnfacedetect::config, dnnfacedetect::getInstance())
		}
	);
```

这里由于人脸检测是一个相对比较复杂的业务，一个函数并不合适。所以用户只能自己通过std::bind()去绑定类的成员函数，进而将复杂的业务逻辑写到类里，通过类的各个成员函数组合完成业务。

在这个例子中，可以说是把代价转移到用户身上了，也许某种程度是合理的，也许是不合理，这点需要更深入的思考。

上述简单描述了一些VTF为了通用性付出的代价。下面简单介绍一个几乎没有代价的设计，即ThreadLoo。

ThreadLoop是一个抽象基类，提供了线程循环的能力，继承类需要实现这个接口即可收获线程循环的能力：

```c++
/**
 * @name: threadLoop
 * @Descripttion: threadLoop is pure virtual function, inheritor must provider a implementation
 * @param {*} none
 * @return {*} true mean continue, false mean stop loop
 */    
virtual bool threadLoop(T item) = 0;
```

这个通用的类并不会给VTF框架内部实现带来什么代价，相反，从中获得了不小的收益。否则，每一个想要获得线程循环能力的类都需要自己编写类似这样的代码：

```c++
//伪代码
std::thread t([]() {
   	while (true) {
        condition.wait();
        bool ret = process();
        if (ret) {
            break;
        }
    } 
});

{
    //balablbal
    condition.notifier.
}
```

光是维护条件变量就足够复杂了，更何况还要考虑如何安全的停止。而用了ThreadLoop，这个事情仅需要在ThreadLoop内部去考虑，外部不需要关心什么条件变量阿，停止的时序啊等等问题。

其他的类似的通过抽象，继承，组合来实现通用性的例子在VTF中还存在很多，本文就不再赘述了，有兴趣的可自行阅读代码。

### 5 小结

本文简单的讨论了一下程序的“通用性”的价值与代价。通用性是一个很大的话题，为了实现通用性，往往需要付出一定的代价，所以我们需要权衡好代价与价值。避免无必要的通用，有时候给用户添加一些“限制”也是一种可取的方式。

作为框架开发者，需要比框架使用者更多的思考通用性的价值与代价。要对什么地方该通用，什么地方不必通用有很强的识别能力，否则可能会发生对某一个点有化了很久，但到最后并没有价值的情况。这又回到了本文的主题：

> 通用性的价值与代价





