diff --git a/src/core/blocking_queue.hpp b/src/core/blocking_queue.hpp
index 0c02199..dcd41aa 100644
--- a/src/core/blocking_queue.hpp
+++ b/src/core/blocking_queue.hpp
@@ -4,7 +4,7 @@
  * @Author: yeonon
  * @Date: 2021-10-16 22:00:26
  * @LastEditors: yeonon
- * @LastEditTime: 2021-11-15 00:01:34
+ * @LastEditTime: 2021-11-17 21:55:47
  */
 #pragma once
 
diff --git a/src/core/notifier.hpp b/src/core/notifier.hpp
index 2a1a3f5..0d24874 100644
--- a/src/core/notifier.hpp
+++ b/src/core/notifier.hpp
@@ -4,7 +4,7 @@
  * @Author: yeonon
  * @Date: 2021-11-14 22:58:29
  * @LastEditors: yeonon
- * @LastEditTime: 2021-11-15 23:28:47
+ * @LastEditTime: 2021-11-17 22:55:32
  */
 #pragma once
 
@@ -14,6 +14,7 @@
 #include <mutex>
 #include <condition_variable>
 #include <memory>
+#include <atomic>
 
 namespace vtf {
 
@@ -38,10 +39,16 @@ public:
         :m_id(m_idGenerator.generate()),
          m_name(name),
          m_readyQueue(readyQueueSize),
-         m_processFunction(std::move(pf))
+         m_processFunction(std::move(pf)),
+         m_isStop(false)
     {
         run();
     }
+    
+    ~Notifier()
+    {
+        VTF_LOGD("notifier {0} destory", m_name);
+    }
 
     /**
      * @name: threadLoop
@@ -60,12 +67,15 @@ public:
     void notify(std::shared_ptr<Item>);
 
     std::string name() { return m_name; }
+
+    void stop();
 private:
     static vtf::util::IDGenerator m_idGenerator;
     long m_id;
     std::string m_name;
     ReadyQueue m_readyQueue;
     NotifierProcessFunction m_processFunction;
+    std::atomic_bool m_isStop;
 };
 
 template<typename Item>
@@ -81,7 +91,7 @@ bool Notifier<Item>::threadLoop()
         return false;
     }
     ret = m_processFunction(item);
-    VTF_LOGD("[{0}] result notifier process item {1}", name(), item->ID());
+    VTF_LOGD("[{0}] result notifier process item {1} useCount {2}", name(), item->ID(), item.use_count());
     return ret;
 }
 
@@ -91,4 +101,16 @@ void Notifier<Item>::notify(std::shared_ptr<Item> item)
     m_readyQueue.push(item);
 }
 
+template<typename Item>
+void Notifier<Item>::stop()
+{
+    m_isStop = true;
+    while (!m_readyQueue.isEmpty()) {
+        //process ready queue item
+        auto item = m_readyQueue.pop();
+        m_processFunction(item);
+    }
+    m_readyQueue.clear();
+}
+
 }
\ No newline at end of file
diff --git a/src/core/pipeline/pipeNode.hpp b/src/core/pipeline/pipeNode.hpp
index dbdda11..bf8111b 100644
--- a/src/core/pipeline/pipeNode.hpp
+++ b/src/core/pipeline/pipeNode.hpp
@@ -4,7 +4,7 @@
  * @Author: yeonon
  * @Date: 2021-10-24 16:17:33
  * @LastEditors: yeonon
- * @LastEditTime: 2021-11-16 22:53:52
+ * @LastEditTime: 2021-11-17 23:20:10
  */
 #pragma once
 #include "../dag.hpp"
@@ -57,7 +57,9 @@ public:
         run();
     }
 
-    ~PipeNode() {}
+    ~PipeNode() {
+        VTF_LOGD("node {0} destory", m_name);
+    }
 
     bool threadLoop() override;
 
@@ -115,6 +117,7 @@ public:
     { 
         std::unique_lock<std::mutex> lk(m_mutex);
         m_isStop = true; 
+        m_processQueue.clear();
         VTF_LOGD("node [{0}:[1]] stop", m_id, name()); 
     }
 
diff --git a/src/core/pipeline/pipeNodeDispatcher.hpp b/src/core/pipeline/pipeNodeDispatcher.hpp
index 50dfed8..91db15c 100644
--- a/src/core/pipeline/pipeNodeDispatcher.hpp
+++ b/src/core/pipeline/pipeNodeDispatcher.hpp
@@ -4,7 +4,7 @@
  * @Author: yeonon
  * @Date: 2021-10-30 15:32:04
  * @LastEditors: yeonon
- * @LastEditTime: 2021-11-16 22:52:29
+ * @LastEditTime: 2021-11-17 22:57:59
  */
 #pragma once
 
@@ -34,7 +34,9 @@ public:
     {}
 
     ~PipeNodeDispatcher()
-    {}
+    {
+        VTF_LOGD("dispatch destory");
+    }
 
     virtual bool dispatch(std::shared_ptr<Item> item) override;
     virtual void queueInDispacther(std::shared_ptr<Item> item) override;
@@ -92,6 +94,7 @@ bool PipeNodeDispatcher<Item>::threadLoop()
 {
     bool ret = true;
     auto req = m_dispatchQueue.pop();
+    VTF_LOGD("request {0} useCount = {1}", req->ID(), req.use_count());
     ret = dispatch(req);
     return ret;
 }
@@ -136,8 +139,10 @@ void PipeNodeDispatcher<Item>::stop()
         });
     }
 
-    VTF_LOGD("pipeline dispacther stop END");
+    VTF_LOGD("when pipeline distapctehr stop, m_dispatchQueue.isEmpty {0}", m_dispatchQueue.isEmpty());
     m_dispatchQueue.clear();
+    m_pipeNodeMaps.clear();
+    VTF_LOGD("pipeline dispacther stop END");
 }
 
 } //pipeline
diff --git a/src/core/pipeline/pipeRequest.hpp b/src/core/pipeline/pipeRequest.hpp
index 5bc3030..c79a0e1 100644
--- a/src/core/pipeline/pipeRequest.hpp
+++ b/src/core/pipeline/pipeRequest.hpp
@@ -4,7 +4,7 @@
  * @Author: yeonon
  * @Date: 2021-10-30 17:45:25
  * @LastEditors: yeonon
- * @LastEditTime: 2021-11-15 23:25:32
+ * @LastEditTime: 2021-11-17 22:39:43
  */
 #pragma once
 
@@ -25,6 +25,11 @@ public:
         :m_id(m_idGenerator.generate())
     {}
 
+    virtual ~Request() {
+        VTF_LOGD("request {0} destory", ID());
+    }
+
+
     long ID() { return m_id; };
 
     /**
@@ -119,6 +124,7 @@ public:
 
     ~PipeRequest()
     {
+        VTF_LOGD("pipe request {0} destory", ID());
     }
 
     bool constructDependency(const std::vector<long>& pipeline, std::shared_ptr<PipeNodeDispatcher<Request>> dispatcher) override;
@@ -249,7 +255,10 @@ bool PipeRequest::checkDependencyIsReady()
 bool PipeRequest::notifyResult()
 {
     for (auto resultNotifier : m_resultNotifiers) {
-        resultNotifier->notify(shared_from_this());
+        // auto resultNotifierSp = resultNotifier.lock();
+        // if (resultNotifierSp) {
+            resultNotifier->notify(shared_from_this());
+        // }
     }
     return true;
 }
diff --git a/src/core/pipeline/pipeline.hpp b/src/core/pipeline/pipeline.hpp
index 9d88df5..c880378 100644
--- a/src/core/pipeline/pipeline.hpp
+++ b/src/core/pipeline/pipeline.hpp
@@ -4,7 +4,7 @@
  * @Author: yeonon
  * @Date: 2021-10-30 18:48:53
  * @LastEditors: yeonon
- * @LastEditTime: 2021-11-16 22:31:17
+ * @LastEditTime: 2021-11-17 22:57:03
  */
 
 #pragma once
@@ -189,7 +189,7 @@ bool PipeLine<Item>::constructPipelinesByScenario()
             } 
         }
     }
-
+    m_pipelineModified = false;
     dumpPipelines();
     return true;
 }
@@ -217,10 +217,9 @@ bool PipeLine<Item>::submit(std::shared_ptr<Item> item)
     }
     item->constructDependency(getPipelineWithScenario(item->scenario()), m_pipeNodeDispatcher);
     
-    for (auto& notifier : m_notifiers) {
+    for (auto notifier : m_notifiers) {
         item->addResultNotifier(notifier);
     }
-    
     m_pipeNodeDispatcher->queueInDispacther(item);
     VTF_LOGD("submit a item {0}", item->ID());
     return true;
@@ -239,6 +238,18 @@ void PipeLine<Item>::stop()
     std::unique_lock<std::mutex> lk(m_mutex);
     m_isStop = true;
     m_pipeNodeDispatcher->stop();
+    for (auto& notifier : m_notifiers) {
+        VTF_LOGD("notifier {0} stop start", notifier->name());
+        notifier->stop();
+        VTF_LOGD("notifier {0} stop end", notifier->name());
+    }
+    //clear info
+    m_pipeNodeMaps.clear();
+    m_pipelines.clear();
+    m_scenario2PipelineMaps.clear();
+    m_pipelineScenarioSet.clear();
+    m_notifiers.clear();
+    m_pipelineModified = true;
     VTF_LOGD("pipeline stop End");
 }
 
diff --git a/src/core/threadLoop.hpp b/src/core/threadLoop.hpp
index f6a6610..083af05 100644
--- a/src/core/threadLoop.hpp
+++ b/src/core/threadLoop.hpp
@@ -4,7 +4,7 @@
  * @Author: yeonon
  * @Date: 2021-10-24 15:39:39
  * @LastEditors: yeonon
- * @LastEditTime: 2021-11-13 00:26:57
+ * @LastEditTime: 2021-11-17 20:59:35
  */
 #pragma once
 
@@ -21,6 +21,13 @@ public:
         :m_isStop(false)
     {}
 
+    ~ThreadLoop()
+    {
+        VTF_LOGD("wait thread process done");
+        m_thread->join();
+        VTF_LOGD("thread process done");
+    }
+
     /**
      * @name: threadLoop
      * @Descripttion: threadLoop is pure virtual function, inheritor must provider a implementation
diff --git a/src/test/testPipeline.cpp b/src/test/testPipeline.cpp
index aa21ab8..78b5064 100644
--- a/src/test/testPipeline.cpp
+++ b/src/test/testPipeline.cpp
@@ -4,7 +4,7 @@
  * @Author: yeonon
  * @Date: 2021-10-30 17:56:49
  * @LastEditors: yeonon
- * @LastEditTime: 2021-11-16 23:15:25
+ * @LastEditTime: 2021-11-17 23:11:08
  */
 #include "../core/pipeline/pipeRequest.hpp"
 #include "../core/pipeline/pipeNodeDispatcher.hpp"
@@ -83,21 +83,21 @@ void testPipeline()
         VTF_LOGD("result {0} notify it", request->ID());
         return true;
     });
-
-    // auto req = std::make_shared<vtf::pipeline::PipeRequest>(MyScenario::Scenario1, false);
-    // ppl.submit(req);
-
+    bool isSTop = false;
+    int cnt = 0;
     while (true) {
-        auto req = std::make_shared<vtf::pipeline::PipeRequest>(MyScenario::Scenario2, false);
-        // if (req->ID() == 100) {
-        //     ppl.stop();
-        //     continue;
-        // } else {
-
-            ppl.submit(req);
+        if (cnt == 100) {
+            ppl.stop();
+            VTF_LOGD("start stop");
+            isSTop = true;
+        } else {
             std::this_thread::sleep_until(vtf::util::TimeUtil::awake_time(33));
-        // }
-
+            if (!isSTop) {
+                auto req = std::make_shared<vtf::pipeline::PipeRequest>(MyScenario::Scenario2, false);
+                ppl.submit(req);
+            }
+        }
+        cnt++;
     }
 }
 
@@ -105,4 +105,7 @@ int main()
 {
     // testDispatch();
     testPipeline();
+    while (true) {
+        
+    }
 }
\ No newline at end of file
